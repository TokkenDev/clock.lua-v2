-- clocklib :3

local ClockLib = {}
ClockLib.__index = ClockLib

local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- theme
local Theme = {
    Background = Color3.fromRGB(22, 22, 24),
    Panel = Color3.fromRGB(28, 28, 30),
    Accent = Color3.fromRGB(0, 170, 255),
    AccentSoft = Color3.fromRGB(40, 100, 200),
    Text = Color3.fromRGB(235, 235, 235),
    MutedText = Color3.fromRGB(170, 170, 170),
    ToggleOn = Color3.fromRGB(0, 200, 120),
    ToggleOff = Color3.fromRGB(80, 80, 90),
    ShadowColor = Color3.fromRGB(0,0,0),
}

-- simple tween helper
local function tween(inst, props, info)
    info = info or TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    TS:Create(inst, info, props):Play()
end

-- rounding helper
local function apply_round(frame, radius)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, radius or 6)
    c.Parent = frame
end

-- shadow helper (uses slice image)
local function apply_shadow(frame)
    local ok, img = pcall(function() return "rbxassetid://1316045217" end)
    if not ok then return end
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "ClockLib_Shadow"
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.Position = UDim2.fromScale(0.5, 0.5)
    shadow.Size = UDim2.new(1, 36, 1, 36)
    shadow.BackgroundTransparency = 1
    shadow.Image = img
    shadow.ImageColor3 = Theme.ShadowColor
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10,10,118,118)
    shadow.ZIndex = frame.ZIndex - 1
    shadow.Parent = frame
end

-- hover helper
local function add_hover(target, hoverProps, normalProps)
    local normal = normalProps or {}
    local hover = hoverProps or {}
    target.MouseEnter:Connect(function()
        tween(target, hover, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
    end)
    target.MouseLeave:Connect(function()
        tween(target, normal, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
    end)
end

-- safe screen gui creator
local function make_screengui(name)
    local sg = Instance.new("ScreenGui")
    sg.Name = name or "ClockLib_GUI"
    sg.ResetOnSpawn = false
    sg.ZIndexBehavior = Enum.ZIndexBehavior.Global
    sg.Parent = game:GetService("CoreGui")
    return sg
end

-- overlay for dropdowns/pickers
local function make_overlay(screenGui)
    local overlay = Instance.new("Frame")
    overlay.Name = "ClockLib_Overlay"
    overlay.Size = UDim2.fromScale(1,1)
    overlay.BackgroundTransparency = 1
    overlay.ZIndex = 9999
    overlay.Parent = screenGui
    return overlay
end

-- slider: accepts windowParam to block window dragging during interaction
local function create_slider(name, min, max, default, increment, theme, callback, windowParam)
    local minv, maxv = min or 0, max or 100
    local incr = increment or 1
    local value = default or minv

    local widget = Instance.new("Frame")
    widget.Size = UDim2.new(1, 0, 0, 36)
    widget.BackgroundTransparency = 1

    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Size = UDim2.new(1, -8, 0, 16)
    label.Position = UDim2.new(0, 8, 0, 2)
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Font = Enum.Font.Gotham
    label.TextSize = 13
    label.TextColor3 = theme.Text
    label.Text = string.format("%s: %d", name or "slider", value)
    label.Parent = widget

    local bar = Instance.new("Frame")
    bar.Name = "Bar"
    bar.Size = UDim2.new(1, -16, 0, 8)
    bar.Position = UDim2.new(0, 8, 0, 22)
    bar.BackgroundColor3 = theme.Panel
    bar.BorderSizePixel = 0
    bar.Parent = widget
    apply_round(bar, 6)

    local fill = Instance.new("Frame")
    fill.Name = "Fill"
    fill.Size = UDim2.new(((value - minv) / math.max(1, (maxv - minv))), 0, 1, 0)
    fill.BackgroundColor3 = theme.Accent
    fill.BorderSizePixel = 0
    fill.Parent = bar
    apply_round(fill, 6)

    local knob = Instance.new("ImageLabel")
    knob.Name = "Knob"
    knob.Size = UDim2.new(0, 14, 0, 14)
    knob.AnchorPoint = Vector2.new(0.5, 0.5)
    knob.Position = UDim2.new(fill.Size.X.Scale, 0, 0.5, 0)
    knob.BackgroundTransparency = 1
    knob.Image = "rbxassetid://3926305904" -- circle, optional
    knob.ScaleType = Enum.ScaleType.Fit
    knob.Parent = bar
    knob.ZIndex = bar.ZIndex + 1

    local dragging = false

    local function block(set)
        if windowParam then
            windowParam._inputBlocked = set and true or false
        end
    end

    local function updateFromX(x)
        local rel = math.clamp((x - bar.AbsolutePosition.X) / bar.AbsoluteSize.X, 0, 1)
        local v = math.floor((minv + rel * (maxv - minv)) / incr + 0.5) * incr
        value = math.clamp(v, minv, maxv)
        local ratio = (value - minv) / math.max(1, (maxv - minv))
        fill.Size = UDim2.new(ratio, 0, 1, 0)
        knob.Position = UDim2.new(ratio, 0, 0.5, 0)
        label.Text = string.format("%s: %d", name or "slider", value)
        if callback then pcall(callback, value) end
    end

    bar.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            block(true)
            updateFromX(inp.Position.X)
        end
    end)
    bar.InputEnded:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
            block(false)
        end
    end)
    knob.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            block(true)
        end
    end)
    UIS.InputEnded:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
            block(false)
        end
    end)
    UIS.InputChanged:Connect(function(inp)
        if dragging and inp.UserInputType == Enum.UserInputType.MouseMovement then
            updateFromX(inp.Position.X)
        end
    end)

    function widget:SetValue(v)
        v = math.clamp(math.floor(v / incr + 0.5) * incr, minv, maxv)
        value = v
        local ratio = (value - minv) / math.max(1, (maxv - minv))
        fill.Size = UDim2.new(ratio, 0, 1, 0)
        knob.Position = UDim2.new(ratio, 0, 0.5, 0)
        label.Text = string.format("%s: %d", name or "slider", value)
        if callback then pcall(callback, value) end
    end

    function widget:GetValue()
        return value
    end

    return widget
end

-- dropdown rendered in overlay; blocks window while open
local function create_dropdown(internalName, options, default, theme, overlay, callback, windowParam)
    local widget = Instance.new("Frame")
    widget.Size = UDim2.new(1, 0, 0, 30)
    widget.BackgroundTransparency = 1

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, 0, 1, 0)
    btn.BackgroundColor3 = theme.Panel
    btn.BorderSizePixel = 0
    btn.AutoButtonColor = false
    btn.TextXAlignment = Enum.TextXAlignment.Left
    btn.Font = Enum.Font.GothamSemibold
    btn.TextSize = 13
    btn.TextColor3 = theme.Text
    btn.Text = (internalName or "option") .. ": " .. (default or "none")
    btn.Parent = widget
    apply_round(btn, 6)

    local caret = Instance.new("TextLabel")
    caret.Size = UDim2.new(0, 20, 1, 0)
    caret.AnchorPoint = Vector2.new(1, 0)
    caret.Position = UDim2.new(1, -6, 0, 0)
    caret.BackgroundTransparency = 1
    caret.Text = "▾"
    caret.Font = Enum.Font.GothamBold
    caret.TextSize = 14
    caret.TextColor3 = theme.MutedText
    caret.Parent = btn

    local list = Instance.new("Frame")
    list.Name = "DropdownList"
    list.Size = UDim2.new(0, 180, 0, math.clamp(#options * 26, 26, 260))
    list.BackgroundColor3 = theme.Panel
    list.BorderSizePixel = 0
    list.Visible = false
    list.Parent = overlay
    apply_round(list, 6)
    list.ZIndex = overlay.ZIndex + 1

    local layout = Instance.new("UIListLayout")
    layout.Parent = list
    layout.Padding = UDim.new(0, 2)
    layout.SortOrder = Enum.SortOrder.LayoutOrder

    local function block(set)
        if windowParam then windowParam._inputBlocked = set and true or false end
    end

    for i, opt in ipairs(options) do
        local optBtn = Instance.new("TextButton")
        optBtn.Size = UDim2.new(1, -8, 0, 24)
        optBtn.Position = UDim2.new(0, 4, 0, 0)
        optBtn.BackgroundTransparency = 1
        optBtn.Text = opt
        optBtn.Font = Enum.Font.Gotham
        optBtn.TextSize = 13
        optBtn.TextColor3 = theme.Text
        optBtn.TextXAlignment = Enum.TextXAlignment.Left
        optBtn.Parent = list

        optBtn.MouseButton1Click:Connect(function()
            btn.Text = (internalName or "option") .. ": " .. opt
            list.Visible = false
            block(false)
            if callback then pcall(callback, opt) end
        end)

        optBtn.MouseEnter:Connect(function()
            tween(optBtn, {TextColor3 = theme.Accent})
        end)
        optBtn.MouseLeave:Connect(function()
            tween(optBtn, {TextColor3 = theme.Text})
        end)
    end

    btn.MouseButton1Click:Connect(function()
        list.Visible = not list.Visible
        if list.Visible then
            local abs = btn.AbsolutePosition
            list.Position = UDim2.fromOffset(abs.X, abs.Y + btn.AbsoluteSize.Y + 4)
            block(true)
        else
            block(false)
        end
    end)

    overlay.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            if list.Visible and not list:IsAncestorOf(inp.Target) and inp.Target ~= btn then
                list.Visible = false
                block(false)
            end
        end
    end)

    function widget:SetOptions(newOptions)
        for _, child in ipairs(list:GetChildren()) do
            if child:IsA("TextButton") then child:Destroy() end
        end
        for i, opt in ipairs(newOptions) do
            local optBtn = Instance.new("TextButton")
            optBtn.Size = UDim2.new(1, -8, 0, 24)
            optBtn.Position = UDim2.new(0, 4, 0, 0)
            optBtn.BackgroundTransparency = 1
            optBtn.Text = opt
            optBtn.Font = Enum.Font.Gotham
            optBtn.TextSize = 13
            optBtn.TextColor3 = theme.Text
            optBtn.TextXAlignment = Enum.TextXAlignment.Left
            optBtn.Parent = list

            optBtn.MouseButton1Click:Connect(function()
                btn.Text = (internalName or "option") .. ": " .. opt
                list.Visible = false
                block(false)
                if callback then pcall(callback, opt) end
            end)

            optBtn.MouseEnter:Connect(function()
                tween(optBtn, {TextColor3 = theme.Accent})
            end)
            optBtn.MouseLeave:Connect(function()
                tween(optBtn, {TextColor3 = theme.Text})
            end)
        end
    end

    return widget
end

-- multi dropdown (checkboxes) rendered in overlay
local function create_multi_dropdown(internalName, options, defaultTable, theme, overlay, callback, windowParam)
    local widget = Instance.new("Frame")
    widget.Size = UDim2.new(1, 0, 0, 30)
    widget.BackgroundTransparency = 1

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, 0, 1, 0)
    btn.BackgroundColor3 = theme.Panel
    btn.BorderSizePixel = 0
    btn.AutoButtonColor = false
    btn.TextXAlignment = Enum.TextXAlignment.Left
    btn.Font = Enum.Font.GothamSemibold
    btn.TextSize = 13
    btn.TextColor3 = theme.Text
    local selected = {}
    if defaultTable then
        for _,v in ipairs(defaultTable) do table.insert(selected, v) end
    end
    local function buildLabel()
        if #selected > 0 then return (internalName or "multi") .. ": " .. table.concat(selected, ", ") end
        return (internalName or "multi") .. ": none"
    end
    btn.Text = buildLabel()
    btn.Parent = widget
    apply_round(btn, 6)

    local list = Instance.new("Frame")
    list.Name = "MultiList"
    list.Size = UDim2.new(0, 220, 0, math.clamp(#options * 26, 26, 300))
    list.BackgroundColor3 = theme.Panel
    list.BorderSizePixel = 0
    list.Visible = false
    list.Parent = overlay
    apply_round(list, 6)
    list.ZIndex = overlay.ZIndex + 1

    local layout = Instance.new("UIListLayout")
    layout.Parent = list
    layout.Padding = UDim.new(0, 2)
    layout.SortOrder = Enum.SortOrder.LayoutOrder

    local function block(set)
        if windowParam then windowParam._inputBlocked = set and true or false end
    end

    for i, opt in ipairs(options) do
        local row = Instance.new("Frame")
        row.Size = UDim2.new(1, -8, 0, 24)
        row.Position = UDim2.new(0, 4, 0, 0)
        row.BackgroundTransparency = 1
        row.Parent = list

        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -28, 1, 0)
        label.Position = UDim2.new(0, 4, 0, 0)
        label.BackgroundTransparency = 1
        label.Text = opt
        label.Font = Enum.Font.Gotham
        label.TextSize = 13
        label.TextColor3 = theme.Text
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = row

        local chk = Instance.new("TextButton")
        chk.Size = UDim2.new(0, 20, 0, 20)
        chk.AnchorPoint = Vector2.new(1, 0)
        chk.Position = UDim2.new(1, -4, 0, 2)
        chk.BackgroundColor3 = table.find(selected, opt) and theme.Accent or theme.Panel
        chk.BorderSizePixel = 0
        chk.Parent = row
        apply_round(chk, 4)

        chk.MouseButton1Click:Connect(function()
            if table.find(selected, opt) then
                table.remove(selected, table.find(selected, opt))
                tween(chk, {BackgroundColor3 = theme.Panel}, TweenInfo.new(0.12))
            else
                table.insert(selected, opt)
                tween(chk, {BackgroundColor3 = theme.Accent}, TweenInfo.new(0.12))
            end
            btn.Text = buildLabel()
            if callback then pcall(callback, selected) end
        end)
    end

    btn.MouseButton1Click:Connect(function()
        list.Visible = not list.Visible
        if list.Visible then
            local abs = btn.AbsolutePosition
            list.Position = UDim2.fromOffset(abs.X, abs.Y + btn.AbsoluteSize.Y + 4)
            block(true)
        else
            block(false)
        end
    end)

    overlay.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            if list.Visible and not list:IsAncestorOf(inp.Target) and inp.Target ~= btn then
                list.Visible = false
                block(false)
            end
        end
    end)

    function widget:SetSelected(t)
        selected = {}
        for _,v in ipairs(t) do table.insert(selected, v) end
        btn.Text = buildLabel()
        if callback then pcall(callback, selected) end
    end
    function widget:GetSelected()
        return selected
    end

    return widget
end

-- toggle widget
local function create_toggle(name, default, theme, callback)
    local widget = Instance.new("Frame")
    widget.Size = UDim2.new(1, 0, 0, 28)
    widget.BackgroundTransparency = 1

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.75, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = name or "toggle"
    label.Font = Enum.Font.Gotham
    label.TextSize = 13
    label.TextColor3 = theme.Text
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = widget

    local sw = Instance.new("Frame")
    sw.Size = UDim2.new(0, 48, 0, 22)
    sw.AnchorPoint = Vector2.new(1, 0.5)
    sw.Position = UDim2.new(1, -6, 0.5, 0)
    sw.BackgroundColor3 = theme.ToggleOff
    sw.BorderSizePixel = 0
    sw.Parent = widget
    apply_round(sw, 12)

    local knob = Instance.new("Frame")
    knob.Size = UDim2.new(0, 18, 0, 18)
    knob.Position = UDim2.new(0, 2, 0.5, -9)
    knob.BackgroundColor3 = Color3.new(1,1,1)
    knob.BorderSizePixel = 0
    knob.Parent = sw
    apply_round(knob, 9)

    local on = default or false
    if on then
        sw.BackgroundColor3 = theme.ToggleOn
        knob.Position = UDim2.new(1, -20, 0.5, -9)
    else
        sw.BackgroundColor3 = theme.ToggleOff
        knob.Position = UDim2.new(0, 2, 0.5, -9)
    end

    sw.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            on = not on
            if on then
                tween(sw, {BackgroundColor3 = theme.ToggleOn}, TweenInfo.new(0.12))
                tween(knob, {Position = UDim2.new(1, -20, 0.5, -9)}, TweenInfo.new(0.12))
            else
                tween(sw, {BackgroundColor3 = theme.ToggleOff}, TweenInfo.new(0.12))
                tween(knob, {Position = UDim2.new(0, 2, 0.5, -9)}, TweenInfo.new(0.12))
            end
            if callback then pcall(callback, on) end
        end
    end)

    function widget:SetState(b)
        on = b and true or false
        if on then
            sw.BackgroundColor3 = theme.ToggleOn
            knob.Position = UDim2.new(1, -20, 0.5, -9)
        else
            sw.BackgroundColor3 = theme.ToggleOff
            knob.Position = UDim2.new(0, 2, 0.5, -9)
        end
        if callback then pcall(callback, on) end
    end
    function widget:GetState()
        return on
    end

    return widget
end

-- keybind widget: blocks window when waiting for key
local function create_keybind(name, defaultKey, theme, callback, windowParam)
    local widget = Instance.new("Frame")
    widget.Size = UDim2.new(1, 0, 0, 28)
    widget.BackgroundTransparency = 1

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.7, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = name or "keybind"
    label.Font = Enum.Font.Gotham
    label.TextSize = 13
    label.TextColor3 = theme.Text
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = widget

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0, 80, 1, 0)
    btn.AnchorPoint = Vector2.new(1, 0)
    btn.Position = UDim2.new(1, -6, 0, 0)
    btn.BackgroundColor3 = theme.Panel
    btn.BorderSizePixel = 0
    btn.Text = (defaultKey and defaultKey.Name) or "none"
    btn.Font = Enum.Font.GothamSemibold
    btn.TextSize = 13
    btn.TextColor3 = theme.Text
    btn.Parent = widget
    apply_round(btn, 6)

    local binding = false
    local key = defaultKey

    local function block(set)
        if windowParam then windowParam._inputBlocked = set and true or false end
    end

    btn.MouseButton1Click:Connect(function()
        binding = true
        block(true)
        btn.Text = "..."
    end)

    local function onInputBegan(input)
        if binding and input.UserInputType == Enum.UserInputType.Keyboard then
            key = input.KeyCode
            btn.Text = key.Name
            binding = false
            block(false)
            if callback then pcall(callback, key) end
        elseif not binding and key and input.KeyCode == key then
            if callback then pcall(callback, key) end
        end
    end

    UIS.InputBegan:Connect(onInputBegan)

    function widget:SetKey(kc)
        key = kc
        btn.Text = kc and kc.Name or "none"
        if callback then pcall(callback, key) end
    end
    function widget:GetKey() return key end

    return widget
end

-- color picker: uses three sliders in overlay and blocks window while open
local function create_colorpicker(name, defaultColor, theme, overlay, callback, windowParam)
    local widget = Instance.new("Frame")
    widget.Size = UDim2.new(1, 0, 0, 30)
    widget.BackgroundTransparency = 1

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.6, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = name or "color"
    label.Font = Enum.Font.Gotham
    label.TextSize = 13
    label.TextColor3 = theme.Text
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Parent = widget

    local preview = Instance.new("Frame")
    preview.Size = UDim2.new(0, 34, 0, 22)
    preview.AnchorPoint = Vector2.new(1, 0.5)
    preview.Position = UDim2.new(1, -6, 0.5, 0)
    preview.BackgroundColor3 = defaultColor or Color3.fromRGB(255,255,255)
    preview.BorderSizePixel = 0
    preview.Parent = widget
    apply_round(preview, 6)

    local pickerFrame = Instance.new("Frame")
    pickerFrame.BackgroundColor3 = theme.Panel
    pickerFrame.Size = UDim2.new(0, 260, 0, 160)
    pickerFrame.Visible = false
    pickerFrame.Parent = overlay
    apply_round(pickerFrame, 8)
    pickerFrame.ZIndex = overlay.ZIndex + 2

    local function block(set) if windowParam then windowParam._inputBlocked = set and true or false end end

    -- convert c3 to rgb ints
    local function c3_to_rgb(c)
        return math.clamp(math.floor(c.R*255),0,255),
               math.clamp(math.floor(c.G*255),0,255),
               math.clamp(math.floor(c.B*255),0,255)
    end

    local R,G,B = c3_to_rgb(defaultColor or Color3.fromRGB(255,255,255))

    local rSlider = create_slider("r", 0, 255, R, 1, theme, function(v) R = v end, windowParam)
    rSlider.Parent = pickerFrame
    rSlider.Position = UDim2.new(0, 8, 0, 8)

    local gSlider = create_slider("g", 0, 255, G, 1, theme, function(v) G = v end, windowParam)
    gSlider.Parent = pickerFrame
    gSlider.Position = UDim2.new(0, 8, 0, 52)

    local bSlider = create_slider("b", 0, 255, B, 1, theme, function(v) B = v end, windowParam)
    bSlider.Parent = pickerFrame
    bSlider.Position = UDim2.new(0, 8, 0, 96)

    local applyBtn = Instance.new("TextButton")
    applyBtn.Size = UDim2.new(0, 80, 0, 28)
    applyBtn.Position = UDim2.new(1, -92, 1, -36)
    applyBtn.AnchorPoint = Vector2.new(1, 0)
    applyBtn.Text = "apply"
    applyBtn.Font = Enum.Font.GothamSemibold
    applyBtn.TextSize = 13
    applyBtn.BackgroundColor3 = theme.Accent
    applyBtn.TextColor3 = theme.Text
    applyBtn.Parent = pickerFrame
    apply_round = apply_round
    apply_round(applyBtn, 6)

    local function refreshPreview()
        local c = Color3.fromRGB(R, G, B)
        preview.BackgroundColor3 = c
        if callback then pcall(callback, c) end
    end

    applyBtn.MouseButton1Click:Connect(function()
        pickerFrame.Visible = false
        block(false)
        refreshPreview()
    end)

    preview.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            pickerFrame.Visible = not pickerFrame.Visible
            if pickerFrame.Visible then
                local abs = preview.AbsolutePosition
                local x = abs.X - (pickerFrame.Size.X.Offset - preview.AbsoluteSize.X)
                pickerFrame.Position = UDim2.fromOffset(x, abs.Y + preview.AbsoluteSize.Y + 6)
                block(true)
            else
                block(false)
            end
        end
    end)

    RunService.RenderStepped:Connect(function()
        if pickerFrame.Visible then
            local c = Color3.fromRGB(R, G, B)
            preview.BackgroundColor3 = c
        end
    end)

    return widget
end

-- notification helper
local function notify(screenGui, title, desc, dur, theme)
    local notif = Instance.new("Frame")
    notif.Size = UDim2.new(0, 300, 0, (desc and 84) or 48)
    notif.Position = UDim2.new(1, -320, 1, -120)
    notif.BackgroundColor3 = theme.Panel
    notif.BorderSizePixel = 0
    notif.Parent = screenGui
    apply_round(notif, 8)
    apply_shadow(notif)

    local t = Instance.new("TextLabel")
    t.Size = UDim2.new(1, -16, 0, 20)
    t.Position = UDim2.new(0, 8, 0, 8)
    t.BackgroundTransparency = 1
    t.Text = title or "notification"
    t.Font = Enum.Font.GothamSemibold
    t.TextSize = 14
    t.TextColor3 = theme.Text
    t.TextXAlignment = Enum.TextXAlignment.Left
    t.Parent = notif

    if desc then
        local d = Instance.new("TextLabel")
        d.Size = UDim2.new(1, -16, 0, 36)
        d.Position = UDim2.new(0, 8, 0, 30)
        d.BackgroundTransparency = 1
        d.Text = desc
        d.TextWrapped = true
        d.Font = Enum.Font.Gotham
        d.TextSize = 13
        d.TextColor3 = theme.MutedText
        d.TextXAlignment = Enum.TextXAlignment.Left
        d.Parent = notif
    end

    tween(notif, {Position = UDim2.new(1, -320, 1, -140)}, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out))
    delay(dur or 3, function()
        tween(notif, {Position = UDim2.new(1, -320, 1, -120)}, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.In))
        wait(0.2)
        pcall(function() notif:Destroy() end)
    end)
end

-- make draggable: only start drag when handle is used and window._inputBlocked == false
local function make_draggable(frame, handle, window)
    local dragging = false
    local dragInput, dragStart, startPos

    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and not (window and window._inputBlocked) then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    handle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)

    UIS.InputChanged:Connect(function(input)
        if input == dragInput and dragging and not (window and window._inputBlocked) then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

-- api: set theme
function ClockLib:SetTheme(newTheme)
    for k,v in pairs(newTheme) do Theme[k] = v end
end

-- create window (main api)
function ClockLib:CreateWindow(config)
    config = config or {}
    local self = setmetatable({}, ClockLib)

    self.Name = config.Name or "ClockLib"
    self.ScreenGui = make_screengui("ClockLib_" .. self.Name:gsub("%s+",""))
    self.Overlay = make_overlay(self.ScreenGui)
    self._inputBlocked = false

    -- main frame
    local Main = Instance.new("Frame")
    Main.Name = "Main"
    Main.Size = UDim2.new(0, 620, 0, 460)
    Main.Position = UDim2.new(0.5, -310, 0.5, -230)
    Main.BackgroundColor3 = Theme.Background
    Main.BorderSizePixel = 0
    Main.Parent = self.ScreenGui
    apply_round(Main, 10)
    apply_shadow(Main)

    -- topbar
    local Topbar = Instance.new("Frame")
    Topbar.Name = "Topbar"
    Topbar.Size = UDim2.new(1, 0, 0, 44)
    Topbar.BackgroundTransparency = 1
    Topbar.Parent = Main

    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Size = UDim2.new(0, 220, 1, 0)
    Title.Position = UDim2.new(0, 12, 0, 0)
    Title.BackgroundTransparency = 1
    Title.Text = self.Name
    Title.Font = Enum.Font.GothamBold
    Title.TextSize = 18
    Title.TextColor3 = Theme.Text
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = Topbar

    local TabStrip = Instance.new("Frame")
    TabStrip.Name = "TabStrip"
    TabStrip.Size = UDim2.new(0.6, 0, 1, 0)
    TabStrip.Position = UDim2.new(0.28, 0, 0, 0)
    TabStrip.BackgroundTransparency = 1
    TabStrip.Parent = Topbar

    local TabLayout = Instance.new("UIListLayout")
    TabLayout.FillDirection = Enum.FillDirection.Horizontal
    TabLayout.SortOrder = Enum.SortOrder.LayoutOrder
    TabLayout.Padding = UDim.new(0, 6)
    TabLayout.Parent = TabStrip

    local CloseBtn = Instance.new("TextButton")
    CloseBtn.Name = "Close"
    CloseBtn.Size = UDim2.new(0, 36, 0, 28)
    CloseBtn.AnchorPoint = Vector2.new(1, 0.5)
    CloseBtn.Position = UDim2.new(1, -12, 0.5, 0)
    CloseBtn.BackgroundColor3 = Theme.Panel
    CloseBtn.BorderSizePixel = 0
    CloseBtn.Text = "✕"
    CloseBtn.Font = Enum.Font.GothamBold
    CloseBtn.TextSize = 14
    CloseBtn.TextColor3 = Theme.Text
    CloseBtn.Parent = Topbar
    apply_round(CloseBtn, 8)

    CloseBtn.MouseButton1Click:Connect(function()
        self:Destroy()
    end)

    -- draggable on topbar only; block during widget interactions
    make_draggable(Main, Topbar, self)

    -- layout: left categories + right content
    local Content = Instance.new("Frame")
    Content.Name = "Content"
    Content.Size = UDim2.new(1, -20, 1, -68)
    Content.Position = UDim2.new(0, 10, 0, 54)
    Content.BackgroundTransparency = 1
    Content.Parent = Main

    local Left = Instance.new("Frame")
    Left.Name = "Left"
    Left.Size = UDim2.new(0, 180, 1, 0)
    Left.BackgroundColor3 = Theme.Panel
    Left.BorderSizePixel = 0
    Left.Parent = Content
    apply_round(Left, 8)

    local Right = Instance.new("Frame")
    Right.Name = "Right"
    Right.Size = UDim2.new(1, -200, 1, 0)
    Right.Position = UDim2.new(0, 200, 0, 0)
    Right.BackgroundColor3 = Theme.Panel
    Right.BorderSizePixel = 0
    Right.Parent = Content
    apply_round(Right, 8)

    local LeftLayout = Instance.new("UIListLayout")
    LeftLayout.Padding = UDim.new(0, 8)
    LeftLayout.SortOrder = Enum.SortOrder.LayoutOrder
    LeftLayout.Parent = Left

    local RightScroller = Instance.new("ScrollingFrame")
    RightScroller.Size = UDim2.new(1, -12, 1, -12)
    RightScroller.Position = UDim2.new(0, 6, 0, 6)
    RightScroller.BackgroundTransparency = 1
    RightScroller.ScrollBarThickness = 8
    RightScroller.Parent = Right

    local RightLayout = Instance.new("UIListLayout")
    RightLayout.Padding = UDim.new(0, 10)
    RightLayout.SortOrder = Enum.SortOrder.LayoutOrder
    RightLayout.Parent = RightScroller

    -- store tabs
    self.Tabs = {}
    self.ScreenGui = self.ScreenGui
    self.Overlay = self.Overlay
    self.Main = Main
    self.Left = Left
    self.Right = RightScroller
    self.TabStrip = TabStrip
    self.CurrentTab = nil

    -- create a tab (top + left + right container)
    function self:CreateTab(tabConfig)
        local name = (tabConfig and tabConfig.Name) or ("tab" .. tostring(#self.Tabs + 1))

        -- top tab button
        local topBtn = Instance.new("TextButton")
        topBtn.Size = UDim2.new(0, 96, 0, 28)
        topBtn.BackgroundTransparency = 1
        topBtn.Font = Enum.Font.GothamSemibold
        topBtn.TextSize = 13
        topBtn.Text = name
        topBtn.TextColor3 = Theme.MutedText
        topBtn.Parent = self.TabStrip
        apply_round(topBtn, 6)

        -- left side button
        local leftBtn = Instance.new("TextButton")
        leftBtn.Size = UDim2.new(1, -12, 0, 36)
        leftBtn.Position = UDim2.new(0, 6, 0, 6)
        leftBtn.BackgroundColor3 = Theme.Panel
        leftBtn.Text = name
        leftBtn.Font = Enum.Font.Gotham
        leftBtn.TextSize = 14
        leftBtn.TextColor3 = Theme.Text
        leftBtn.BorderSizePixel = 0
        leftBtn.Parent = self.Left
        apply_round(leftBtn, 6)
        add_hover(leftBtn, {BackgroundColor3 = Theme.AccentSoft}, {BackgroundColor3 = Theme.Panel})

        -- right container
        local rightContainer = Instance.new("Frame")
        rightContainer.Size = UDim2.new(1, -12, 1, 0)
        rightContainer.BackgroundTransparency = 1
        rightContainer.Visible = false
        rightContainer.Parent = self.Right
        rightContainer.LayoutOrder = #self.Tabs + 1

        local containerLayout = Instance.new("UIListLayout")
        containerLayout.Parent = rightContainer
        containerLayout.Padding = UDim.new(0, 8)
        containerLayout.SortOrder = Enum.SortOrder.LayoutOrder

        local tab = {
            Name = name,
            TopButton = topBtn,
            LeftButton = leftBtn,
            Container = rightContainer,
            Sections = {}
        }

        local function select()
            if self.CurrentTab then
                self.CurrentTab.Container.Visible = false
                self.CurrentTab.TopButton.TextColor3 = Theme.MutedText
                self.CurrentTab.LeftButton.BackgroundColor3 = Theme.Panel
                self.CurrentTab.LeftButton.TextColor3 = Theme.Text
            end
            tab.Container.Visible = true
            tab.TopButton.TextColor3 = Theme.Accent
            tab.LeftButton.BackgroundColor3 = Theme.AccentSoft
            tab.LeftButton.TextColor3 = Color3.fromRGB(255,255,255)
            self.CurrentTab = tab
        end

        topBtn.MouseButton1Click:Connect(select)
        leftBtn.MouseButton1Click:Connect(select)

        if #self.Tabs == 0 then select() end

        -- create section inside tab
        function tab:CreateSection(secConfig)
            local sname = (secConfig and secConfig.Name) or "section"
            local section = Instance.new("Frame")
            section.Size = UDim2.new(1, -12, 0, 0)
            section.BackgroundTransparency = 1
            section.Parent = tab.Container

            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 0, 20)
            title.BackgroundTransparency = 1
            title.Text = sname
            title.Font = Enum.Font.GothamBold
            title.TextSize = 14
            title.TextColor3 = Theme.Text
            title.TextXAlignment = Enum.TextXAlignment.Left
            title.Parent = section

            local content = Instance.new("Frame")
            content.Size = UDim2.new(1, 0, 0, 8)
            content.Position = UDim2.new(0, 0, 0, 26)
            content.BackgroundTransparency = 1
            content.Parent = section

            local contentLayout = Instance.new("UIListLayout")
            contentLayout.Parent = content
            contentLayout.Padding = UDim.new(0, 8)
            contentLayout.SortOrder = Enum.SortOrder.LayoutOrder

            -- widgets factories (pass window param where needed)
            function section:CreateButton(cfg)
                local btn = Instance.new("TextButton")
                btn.Size = UDim2.new(1, 0, 0, 32)
                btn.BackgroundColor3 = Theme.AccentSoft
                btn.BorderSizePixel = 0
                btn.Font = Enum.Font.GothamSemibold
                btn.TextSize = 13
                btn.Text = cfg.Name or "button"
                btn.TextColor3 = Theme.Text
                btn.Parent = content
                apply_round(btn, 6)
                add_hover(btn, {BackgroundColor3 = Theme.Accent}, {BackgroundColor3 = Theme.AccentSoft})
                if cfg.Callback then btn.MouseButton1Click:Connect(cfg.Callback) end
                return btn
            end

            function section:CreateToggle(cfg)
                local toggle = create_toggle(cfg.Name or "toggle", cfg.Default or false, Theme, cfg.Callback)
                toggle.Parent = content
                return toggle
            end

            function section:CreateSlider(cfg)
                local slider = create_slider(cfg.Name or "slider", cfg.Min or 0, cfg.Max or 100, cfg.Default or (cfg.Min or 0), cfg.Increment or 1, Theme, cfg.Callback, self and self.Parent and self.Parent.Parent and self.Parent.Parent.Parent and (self.Parent.Parent.Parent._windowRef) or nil)
                -- the above tries to find window ref if available; we'll set _windowRef later for reliability
                if not slider then return end
                slider.Parent = content
                return slider
            end

            function section:CreateDropdown(cfg)
                local dropdown = create_dropdown(cfg.Name or "dropdown", cfg.Options or {}, cfg.Default or cfg.Options[1], Theme, self.Parent and self.Parent.Parent and self.Parent.Parent.Parent and self.Parent.Parent.Parent.Overlay or self and self.Parent and self.Parent.Parent and self.Parent.Parent.Overlay or self and self.Parent and self.Overlay or (self and self.Overlay) or self and self.Parent and self.Parent.Overlay or self and self.Overlay, cfg.Callback, section and section.Parent and section.Parent.Parent and section.Parent.Parent._windowRef)
                -- safe fallback: we'll reassign parent's overlay and window ref below
                dropdown.Parent = content
                return dropdown
            end

            function section:CreateMultiDropdown(cfg)
                local md = create_multi_dropdown(cfg.Name or "multidrop", cfg.Options or {}, cfg.Default or {}, Theme, self.Parent and self.Parent.Parent and self.Parent.Parent.Parent and self.Parent.Parent.Parent.Overlay or self and self.Overlay, cfg.Callback, section and section.Parent and section.Parent.Parent and section.Parent.Parent._windowRef)
                md.Parent = content
                return md
            end

            function section:CreateKeybind(cfg)
                local kb = create_keybind(cfg.Name or "keybind", cfg.Default or nil, Theme, cfg.Callback, section and section.Parent and section.Parent.Parent and section.Parent.Parent._windowRef)
                kb.Parent = content
                return kb
            end

            function section:CreateColorPicker(cfg)
                local cp = create_colorpicker(cfg.Name or "color", cfg.Default or Color3.fromRGB(255,255,255), Theme, self.Parent and self.Parent.Parent and self.Parent.Parent.Parent and self.Parent.Parent.Parent.Overlay or self and self.Overlay, cfg.Callback, section and section.Parent and section.Parent.Parent and section.Parent.Parent._windowRef)
                cp.Parent = content
                return cp
            end

            table.insert(tab.Sections, section)
            return section
        end

        table.insert(self.Tabs, tab)
        -- attach window reference so inner factories can find it more reliably
        rightContainer._windowRef = self
        leftBtn._windowRef = self
        topBtn._windowRef = self

        return tab
    end

    -- expose notify
    function self:Notify(title, desc, duration)
        notify(self.ScreenGui, title, desc, duration, Theme)
    end

    -- clean destroy
    function self:Destroy()
        if self.ScreenGui then
            pcall(function() self.ScreenGui:Destroy() end)
            self.ScreenGui = nil
        end
    end

    return self
end

return ClockLib
